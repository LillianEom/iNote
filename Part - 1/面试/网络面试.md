# 网络

11 网络基础部分：传输层>网络层>链路层          TCP/IP协议相关的    

OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
每一层的作用如下：
物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）
网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
会话层：建立、管理和终止会话（会话协议数据单元SPDU）
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

端口号位于几层协议？
TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。

### 1. http和https的区别

* http是http协议运行在tcp之上，所传输的内容都是明文，客户端和服务器端都无法验证对方的身份。


* https是http协议运行在SSL/TLS之上，SSL/TLS运行在tcp之上。所有传输的内容都经过加密。加密采用对称加密，但对称加密的秘钥用服务器方的证书进行非对称加密，此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。
* https协议需要到CA申请证书，一般免费证书很少，需要缴费;
* http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议;
* http和https使用的是完全不同的链接方式，所用的端口也不一样，前者是80，后者是443;
* http的链接很简单，是无状态的。

**HTTP的特点**

支持客户／服务器模式

简单快速：客户向服务端请求服务时，只需传送请求方式和路径。

灵活：允许传输任意类型的数据对象。由Content-Type加以标记。

无连接：每次响应一个请求，响应完成以后就断开连接。

无状态：服务器不保存浏览器的任何信息。每次提交的请求之间没有关联。

### 2. HTTP1.1和HTTP1.0的区别,

参考：[http://blog.csdn.net/hguisu/article/details/8608888](http://blog.csdn.net/hguisu/article/details/8608888)持久连接–connection，一个tcp连接上可以传送多个请求； 

host域–使用虚拟主机技术，这样可以区分一台主机上的多个应用； 增加了一些请求方法HTTP的状态码含义：1.信息，2.成功，3.重定向，4.客户端错误，5.服务器端错误，参考：[http://www.w3school.com.cn/tags/html_ref_httpmessages.asp](http://www.w3school.com.cn/tags/html_ref_httpmessages.asp)

大致了解HTTP协议格式，明白post和get区别，查看过request和response的具体样本
状态码长连接与短连接的区别（LVS是通过长连接作负载均衡）（百度/阿里/豌豆荚）格式

### 3. Get和Post的区别

- 浏览器对url的长度有限制，所以get请求不能代替post请求发送大量数据（get传送数据少，post的传输数据大）；


- get请求不安全（传输过程中是明文的）（post是安全的）；
- get请求是幂等的（多个请求返回同一个结果）（感觉像缓存似的)；
- post请求不能被缓存；

为什么POST效率低：

Get效率高Get将参数拼成URL,放到header消息头里传递

Post直接以键值对的形式放到消息体中传递。但两者的效率差距很小很小

#### 在以下情况中，请使用post请求：

```
* 1、无法使用缓存文件（更新服务器上的文件或数据库）;
* 2、向服务器发送大量数据（post没有数据量限制）;
* 3、发送包含未知字符的用户输入时，post比get更稳定也更可靠;
```

### 4.TCP和UDP区别？如何改进TCP

TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。

TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。

TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

- UDP使用尽最大努力交付，即不保证可靠交付，同时也不能使用拥塞控制；
- UDP是面向报文，UDP没有拥塞控制，很适合多媒体通信要求；
- UDP支持一对一，一对多，多对一和多对多的交互通信；
- UDP的首部开销小，只有8个字节；
- 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点（一对一）；
- TCP提供全双工通道 （html5 websocket就是采用全双工通道）；
- TCP是面向字节流的；
- 首部最低20个字节；

TCP加快传输效率的方法  采取一致确认的机制。

### 5. TCP如何保证可靠传输？

* 数据报校验;
* 超时重传机制;
* 应答机制;
* 对失序数据包重排序;
* TCP还能提供流量控制;

#### TCP是什么：（通信协议）

是一种面向连接、可靠、基于字节流的传输层通信协议。

#### TCP的组成部分：

特别要注意的信息：
ACK:TCP协议规定，只有ACK=1时有效，也就是连接建立后所有发送的报文ACK必须为1;
SYN:在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。若对方同意建立连接，则响应的报文中使SYN=1和ACK=1.（SYN置1表示这是一个连接请求或连接接受报文）
FIN(finish)表示终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送数据已经发送完毕，并要求释放连接。

### 6. 三次握手过程？四次挥手过程？

![](http://om4rextnc.bkt.clouddn.com/17-8-4/35495131.jpg)

#### 三次握手

* 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
* 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

总结：三次握手，对于每一方来说，可以确认两个信息：

**1.确认自己可以接收对方发来的报文段**

**2.确认对方收到了自己的报文段**

一旦这两个得到确认，连接就建立起来了，后面才开始传送数据

#### **四次挥手**

TCP的关闭连接有哪些动作？（四次挥手）？与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。

* 第一次挥手：主动关闭方发送一个FIN，用来**关闭主动方到被动关闭方的数据传送**，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
* 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
* 第三次挥手：被动关闭方发送一个FIN，用来**关闭被动关闭方到主动关闭方的数据传送**，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
* 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

### 7. 为什么进行三次握手，两次确认，两次握手，一次确认不行么？

问题的根源在于防止已失效的链接请求报文段又传送到server，产生错误。

#### 什么是“已失效的链接请求报文段”

* 考虑一种正常的情况:

  A发出链接请求，但因链接请求报文丢失而未收到确认（可能网络阻塞、断网、断电等）。于是A再重传一次链接请求，后来收到确认（网络环境变好了），建立了链接。数据传输完毕后，就释放了链接。A共发送两个链接请求报文段，其中第一个丢失，第二个到达了B。没有“已失效的链接请求。

* 现假定一种异常情况，A发送的第一个链接请求报文段并没有丢失，而在某些网络结点长时间滞留，以致延误到链接释放以后的某个时间才到达B。本来这是一个早已失效的报文段，但B收到此失效的链接请求报文段后，就误认为是A又发出一次新的链接请求。于是向A发出确认报文段，同意建立连接。假设不采用三次握手，那么只要B发出确认，新的链接就建立。

* 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输链接已经建立了，并一直等待A发来数据。从而造成B的许多资源白白浪费。

* 采用三次握手的办法就可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认，B由于收不到确认，就知道A并没有要求建立连接。

采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。**

**注意：**在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。

### 8..为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

### 为什么等待？

  假设A回复的确认信息一发送，就断开连接，而这个确认信息在发送的过程中丢失，B在规定时间内没有收到确认，就会重传。若A有time_wait，就会再次确认信息发送。不然会出现异常关闭。
  另外B存在一个保活状态，即使A突然故障死机，那B那边的链接资源什么时候释放呢？就是保活时间到了后，B会发送探测信息，以决定是否释放连接。

### 9.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

TIME_WAIT状态的原因

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。让4次握手关闭流程更加可靠;

4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。如果主动关闭端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么当主动端ACK丢失，被动方将重发最终的FIN，而主动端将响应RST，被动端收到后将此分节解释成一个错误(在java中会抛出connection reset的SocketException)。

### 10.在四次挥手的过程中有两个状态TIME_WAIT和CLOSE_WAIT之间会发生一些异常情况，你知道是什么？

[http://network.chinabyte.com/87/13312087.shtml](http://network.chinabyte.com/87/13312087.shtml)[http://www.cnblogs.com/sunxucool/p/3449068.html](http://www.cnblogs.com/sunxucool/p/3449068.html)

服务器异常

1.服务器保持了大量TIME_WAIT状态

2.服务器保持了大量CLOSE_WAIT状态

### 11. 从输入网址到获得网页的过程

- （1）查询DNS,获取域名对应的ip地址；

  - 1）浏览器搜索自身的DNS缓存；
  - 2）搜索操作系统的DNS缓存；
  - 3）读取本地的HOST文件；
  - 4）发起一个DNS系统调用；

  A、宽带运营服务器查看本身缓存；
  B、运营商服务器发起一个迭代DNS解析请求；

- （2）浏览器获得域名对应的ip地址后，发起HTTP三次握手；


- （3）TCP/IP链接建立起来后，浏览器就可以向服务器发送HTTP请求;
- （4）服务器接收到这个请求，根据路径参数，经过后端的一些处理生成html页面代码返回给浏览器;
- （5）浏览器拿到完整的html页面代码开始解析和渲染，如果遇到引用外部的js,css，图片等静态资源，它们同样也是一个个的http请求，都需要经过上面的步骤。






### 请分别说明HTTP、TCP、IP三层协议中，接收端如何判断已接受完对端发送来的数据？

在http中，会有一个状态代码，一般状态代码等于200表示接收完成，不等于200就会出现其他错误，比如404访问路径错误和500服务器没有反应等等。
在ip数据包中会有一个数据包开始和结束标识符，并且在获得数据后会对数据进行一个校验来判断是否有数据在传输过程中丢失
（1）HTTP协议的服务端响应报文里有Content-Length字段，明确了报文的长度。客户端应该是通过这个来判断的。
（2）TCP协议里接收方要回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据传完了。有时数据发送方如果发送完毕，会发出中断连接请求。对方也就知道已经发送完毕了。
（3）IP协议是无连接协议，不会考虑对方是否“发送完毕”。如果IP数据报被分片发送，那么只有最后一个分片的“还有分片（M）”flag置为0，之前的分片相应flag都置为1。



### TCP的流量控制怎么解决？（滑动窗口）

### TCP的拥塞控制怎么解决？

（涉及慢开始和拥塞避免，快重传和快恢复。）拥塞避免/慢启动/快重传/快速恢复（所有公司都有问）
TCP的慢启动、快重传：tcp有一个接收窗口用于流量控制，窗口为1是停等协议，效率低下，如果窗口太大，那么可能会出现网络拥塞。所以拥塞控制依赖于拥塞窗口（cwnd）来进行控制。慢启动有点类似于车辆启动的时候，具体待阐述，参考：[http://blog.csdn.net/loverooney/article/details/38323907](http://blog.csdn.net/loverooney/article/details/38323907)

另外我自己还准备了HTTPS和TCP的慢启动和拥塞控制
**回退N帧协议**

### 在浏览器中输入www.baidu.com后执行的全部过程

https://github.com/wangning0/Autumn_Ning_Blog/blob/master/blogs/10-15/url_to_render.md
1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。



### 请分别说明HTTP、TCP、IP三层协议中，接收端如何判断已接受完对端发送来的数据？

在http中，会有一个状态代码，一般状态代码等于200表示接收完成，不等于200就会出现其他错误，比如404访问路径错误和500服务器没有反应等等。
在ip数据包中会有一个数据包开始和结束标识符，并且在获得数据后会对数据进行一个校验来判断是否有数据在传输过程中丢失
（1）HTTP协议的服务端响应报文里有Content-Length字段，明确了报文的长度。客户端应该是通过这个来判断的。
（2）TCP协议里接收方要回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据传完了。有时数据发送方如果发送完毕，会发出中断连接请求。对方也就知道已经发送完毕了。
（3）IP协议是无连接协议，不会考虑对方是否“发送完毕”。如果IP数据报被分片发送，那么只有最后一个分片的“还有分片（M）”flag置为0，之前的分片相应flag都置为1。

### Socket编程的步骤

**基于TCP的socket编程是采用的流式套接**

在这个程序中，将两个工程添加到一个工作区。要链接一个ws2_32.lib的库文件。

* 服务器端编程的步骤：
  * 加载套接字库，创建套接字(WSAStartup()/socket())；
  * 绑定套接字到一个IP地址和一个端口上(bind())；
  * 将套接字设置为监听模式等待连接请求(listen())；
  * 请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；
  * 用返回的套接字和客户端进行通信(send()/recv())
  * 返回，等待另一连接请求；
  * 关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。
* 客户端编程的步骤：
  1. 加载套接字库，创建套接字(WSAStartup()/socket())；
  2. 向服务器发出连接请求(connect())；
  3. 和服务器端进行通信(send()/recv())；
  4. 关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。


**基于UDP的socket编程是采用的数据报套接字。**
在这个程序中，将两个工程添加到一个工作区。同时还要链接一个ws2_32.lib的库文件。

* 服务器端编程的步骤：
  1. 加载套接字库，创建套接字(WSAStartup()/socket())；
  2. 绑定套接字到一个IP地址和一个端口上(bind())；
  3. 等待和接收数据(sendto()/recvfrom())；
  4. 关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。
* 对于基于UDP的socket客户端来说，要进行如下步骤：
  1. 创建一个套接字(socket)；
  2. 向服务器发送数据(sendto);
  3. 关闭套接字；










































