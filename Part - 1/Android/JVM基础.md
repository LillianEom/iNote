## jvm 内存结构（内存分配）

谈 Android 的内存，就不能不提 Java 的内存管理。Java 程序在运行的过程中会将其管理的内存分为若干个不同的数据区：

![](http://i1.piimg.com/567571/64a3345ec0aa6f17.png)

* **方法区**（线程共享）:

  用于存储已被虚拟机加载的**类信息、常量、静态变量**，所有线程共享区域。

  **注意：**特别注意静态变量 static 修饰的变量在方法区

  * 运行时常量池（是方法区的一部分） 

    常量不一定只有在编译器产生，在运行期也可以（如 String 的 intern（方法））。

* **虚拟机栈**  （就是常说的栈，线程私有）:

  每个方法在执行的同时都会创建一个**栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口**等信息，线程私有区域。

  1. （栈内存）为虚拟机执行 Java 方法服务：方法被调用时创建栈帧–>局部变量表–>局部变量–>对象引用 
  2. 如果线程请求的栈深度超出了虚拟机所允许的深度，StackOverFlowError. -Xss规定了栈的最大空间; 
  3. 虚拟机栈可以动态扩展，如果扩展到无法申请到足够的内存，会出现OOM（OutOfMemoryError）


  而我们最常用的就是**局部变量**表，局部变量表包括如下内容： 

> 基本数据类型: boolean byte char short int float long double 注意基本类型的包装类型：Boolean、Byte、Character、Short、Integer、Float、	Long、	Double 
>
> 对象引用类型：类、接口、数组 （不是对象本身，可能是一个指向对象起始地址的引用指针） 
>
> 问题：包装类型是放在栈中么：String Interget（看包装类型是怎么用的：若直接定义则内容在常量池中，若 new 一个对象则在堆中）

* **本地方法栈**：

  与虚拟机栈类似，区别是**虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务**。

* **堆**（线程共享）:

  1. **JVM 管理的内存中最大的一块，所有线程共享；**
  2. **用来存放对象实例，几乎所有的对象实例都在堆上分配内存；**
  3. **物理上不连续，逻辑上连续，并可以动态扩展，此区域也是垃圾回收器（Garbage Collection）主要的作用区域，内存泄漏就发生在这个区域**。

* **程序计数器**:

  **可看做是当前线程所执行的字节码的行号指示器**；如果线程在执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是 Native 方法，这个计数器的值为空（Undefined）。

## GC 算法（内存回收）

### 标记 - 清除 算法（Mark and Sweep GC）

最基础的收集算法：分为“标记”和“清除”两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。

* 标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的视为垃圾对象；
* 清除阶段：清除所有未被标记的对象。

这种方法有两个不足点：

1. 效率问题，标记和清除两个过程的效率都不高；
2. 空间问题，标记清除之后会产生大量的不连续的内存碎片。

![](http://p1.bpimg.com/567571/61e68c171a24b7c4.png)

### 复制 算法(Copying）

将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。
这种方法的特点：

- 优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；
- 缺点：粗暴的将内存缩小为原来的一半，代价实在有点高。

![](http://p1.bpimg.com/567571/f8df2c28c4a9a565.png)

### 标记 - 整理 算法(Mark-Compact)

先标记需要回收的对象（标记过程与“标记-清除”算法一样），然后把所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

* 标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的视为垃圾对象
* 整理阶段：将所有的存活对象压缩到内存的一端（或向一端移动），之后清理边界所有的空间。

这种方法的特点：

- 避免了内存碎片；
- 避免了“复制”算法50%的空间浪费；
- 主要针对对象存活率高的老年代。

![](http://p1.bqimg.com/567571/af51de3a2a88c37d.png)

### 分代收集 算法 

根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。

* 新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
* 老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。

### 三种算法的比较

* 效率：复制算法 > 标记-整理算法 > 标记-清除算法（此处的效率只是简单的对比时间复杂度）
* 内存整理度：复制算法 = 标记-整理算法 》标记-清除算法
* 内存利用率：标记-整理算法 = 标记-清除算法 》复制算法

## 对象是否回收的依据

#### 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1；引用失效时，计数器值减1；任意时刻计数器为0的对象就是不可能再被使用的，表示该对象不存在引用关系。
这种方法的特点：

- 优点：实现简单，判定效率也很高；
- 缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。

#### 可达性分析算法

以一系列成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达），则证明此对象是不可用的。

![](http://p1.bqimg.com/567571/efd5b9b84108f40b.jpg)

































































